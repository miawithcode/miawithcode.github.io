[{"content":" ","date":"2023-03-15","permalink":"/blog/","section":"Blog","summary":" ","title":"Blog"},{"content":"","date":"2023-03-15","permalink":"/tags/frontend/","section":"Tags","summary":"","title":"frontend"},{"content":"","date":"2023-03-15","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":" HTML, CSS \u0026amp; JavaScript # 在学习前端前，需要了解一些基本的知识，比如HTML、 CSS 和 JavaScript。我在学习这些基础时，总想着把YouTube上所有的教程看完，因为觉得这个教程好，那个教程也好，我如果不全都看完可能会错过一些什么。但问题是：\n这些教程有80%相似的内容 在看完了几个教程后，我发现我还是不会写网页 于是在这里犯了第一个错误：教程地狱（Tutorial Hell）。看教程只是学习编程的第一步，看了教程学了基础，应该试着做项目来巩固理解学过的东西，而不是不停地看一个又一个教程。\n所以每个技术应该只选择一个教程并把它看完，我的选择是：\nHTML Full Course for free 🌎 (2023) CSS Full Course for free 🎨 (2023) JavaScript Full Course for free 🌐 (2023) 看完教程后，可以阅读一些完整的在线文档来查缺补漏：\nHTML - W3Schools - HTML Tutorial CSS - W3Schools - CSS Tutorial JavaScript - MDN JavaScript 但是要注意不要困于基础（Stuck In Basics），不要认为必须知道所有的基础概念后才能开始做项目。看完教程后就可以练习一些简单的项目了，阅读文档只是为了补足知识的缺漏。学习前端（或编程）应该花最少的时间看，花最多的时间做。\n完成了这些基础的学习后，可以用一些游戏测试自己对知识的掌握程度：\nCSS CSS Diner: 一个餐桌游戏，通过CSS选择器来选中不同的盘子或食物。 Flexbox Froggy: 练习Flexbox的不同属性值，让青蛙回到对应的荷叶上。 Grid Garden: 练习Grid的不同属性值，给胡萝卜浇水。 JavaScript JavaScript Quiz JS Robot 一些项目的推荐：\n50project50days: 每天做一个小的网呀项目一共50天，一共50个项目。比如拓展卡片，隐藏和展开搜索框等。 JavaScript30 HTML CSS JavaScript projects for beginners 2023 - 12 js projects with source code Learn JavaScript by Building 7 Games - Full Course Build 15 JavaScript Projects - Vanilla JavaScript Course CSS Framework # 到了这个阶段时，我们会发现CSS代码非常冗长以及难以维护，所以我们需要CSS框架来帮助开发，简化流程。现在流行的CSS框架有 Bootstrap 和 Tailwind CSS。但是用Bootstrap写的网站大多千篇一律，Tailwind提供了更强大的定制能力，可以写出更自定义的网站，所以我会学习Tailwind CSS。\nTailwind有完整的文档可供学习，但是我会先看完一个1小时内的Tailwind教程再开始看文档，这样的学习心智负担会更小。\nTailwind CSS Tutorial Tailwind CSS Docs 学习Tailwind，不需要记住所有东西，只需要对Tailwind有大概的了解，知道它是如何起作用的就够了。\n学完Tailwind基础概念后，可以练习怎么用Tailwind做一个Instagram Story：\nRebuilding the Instagram Stories UI with Tailwind CSS 如果在做项目的过程中遇到了不懂或不熟悉的概念，就在Tailwind文档中找到它再看一次，Learn By Doing。\nJavaScript Framework # 学完Tailwind CSS后，可以开始学习JavaScript框架。现在流行的JavaScript框架有 React, Vue, Angular。我选择学习React。\n在学习React之前必须保证有坚实的JavaScrip基础，可以翻阅一遍 JavaScript Info再开始学习React：\nReact Tutorial for Beginners React Docs Build Project # 在对Tailwind和React有了一定的理解后，可以用它们做一些网站克隆项目:\nReact \u0026amp; Tailwind CSS Image Gallery 🔴 Let\u0026rsquo;s build LinkedIn with REACT.JS! (with Redux \u0026amp; Firebase) React JS Crash Course for Beginners - Build 4 Apps in 12 Hours (Redux, Firebase, Auth + More) [2023] 接下来可以试着用Next.js来做项目，Next.js是进阶版React。\n🔴 Let\u0026rsquo;s build Facebook 2.0 with REACT.JS! (Next.js, Tailwind CSS, Image Uploading, Facebook Login) 🔴 Let\u0026rsquo;s build Hulu 2.0 with REACT.JS! (Next.js, Tailwind CSS, Responsive) Portfolio # 学了这么多技术后，我们需要一个作品集网站来展示我们的作品，作品可以是：\n日常会使用的一些流行网站的克隆 根据自己的生活需求创建的工具 谨慎地选择我们要做的项目，因为我们会回来为这些前端项目加上后端的功能。\nNode.js, Express.js \u0026amp; MongoDB # Node.js是可以在服务器上运行的JavaScript环境， Express.js是针对Node.js的框架。 MongoDB是数据库，用于存储网页上用户提供的数据。\nNode.js App From Scratch | Express, MongoDB \u0026amp; Google OAuth 因为我们从做项目中学习，如果在任何概念上卡住了，就善用搜索引擎。在工作中，任何程序员都不是所有概念都准备好了才开始做项目的。\nBring Frontend and Backend Together # 🔴 Build a Whatsapp Clone with MERN Stack (MongoDB, Express, React, Node JS) 做完这个项目后，就可以回到自己的Portfolio项目中，添加一些后端的功能。\n","date":"2023-03-15","permalink":"/blog/how-i-learn-frontend/","section":"Blog","summary":"学习前端的路线与用到的资源","title":"如果能重来，我会怎么学习前端"},{"content":" 你好，我是小绵，做前端开发的。\n我通过写博客来逼自己阅读，用输出强迫自己输入。\n关心生产力、互联网、前端技术、个人成长、效率类工具等话题。\n遇到有所感悟和启发的信息时，我会分享到 Twitter 和 Telegram。\n如果你好奇我 现在正在做的事情 → ，也可以了解更多 关于我 → 的信息。\n","date":"2023-03-15","permalink":"/","section":"小綿尾巴","summary":"你好，我是小绵，做前端开发的。","title":"小綿尾巴"},{"content":"","date":"2023-03-08","permalink":"/tags/javascript/","section":"Tags","summary":"","title":"javascript"},{"content":"","date":"2023-03-08","permalink":"/tags/project/","section":"Tags","summary":"","title":"project"},{"content":"","date":"2023-03-08","permalink":"/project/","section":"Projects","summary":"","title":"Projects"},{"content":"我们都玩过贪吃蛇游戏，在写出一个贪吃蛇游戏前，先复习一下游戏的玩法：\n贪吃蛇向食物格移动，用方向键控制贪吃蛇的移动方向。 每吃下一个食物格，贪吃蛇的身体会增长一格。 当贪吃蛇碰到游戏四周的边界线，或者咬到自己的身体，则游戏结束。 Live Demo: https://mia-snake-game.netlify.app/ Source Code: https://github.com/miawithcode/snake-game Prerequisite # 这篇博文假设你已经学过JavaScript中的：\nArray Object HTML Canvas DOM addEventListener() UI Events setTimeout() HTML # 写一个JavaScript程序一定会从HTML开始，写出页面的基本骨架，这里会用到HTML5的\u0026lt;canvas\u0026gt;标签：\n\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;canvas id=\u0026#34;gameBoard\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;500\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;div id=\u0026#34;scoreDisplay\u0026#34;\u0026gt;0\u0026lt;/div\u0026gt; \u0026lt;button id=\u0026#34;restartBtn\u0026#34;\u0026gt;Play Again\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 用gameBoard的\u0026lt;canvas\u0026gt;来定义一个宽500px，高500px的画布，用JavaScript在画布上绘制贪吃蛇与食物。 用scoreDisplay的\u0026lt;div\u0026gt;来显示当前获得的游戏分数。 用restartBtn按钮\u0026lt;button\u0026gt;重新开始游戏。 CSS # #gameBorad{ border: 3px solid; } 只有「添加画布的边框」这件事是最重要的，因为玩家需要看到贪吃蛇不能碰到的“四个墙壁”，其他元素的样式可加可不加。\nJavaScript # 第一件事，声明需要的变量。\n选中JavaScript中的元素：\nconst gameBoard = document.querySelector(\u0026#34;#gameBoard\u0026#34;); const context = gameBoard.getContext(\u0026#34;2d\u0026#34;); const scoreDisplay = document.querySelector(\u0026#34;#scoreDisplay\u0026#34;); const restartBtn = document.querySelector(\u0026#34;#restartBtn\u0026#34;); 选中\u0026lt;canvas\u0026gt;元素，创建context对象。getContext(\u0026quot;2d\u0026quot;)对象是内建的 HTML5 对象，可以绘制各种图形。 选中分数显示scoreDisplay和重启按钮restartBtn。 声明游戏画布的宽度与高度：\nconst gameWidth = gameBoard.width; const gameHeight = gameBoard.height; 声明颜色，在画布上绘制图形时使用：\nconst boardBackground = \u0026#34;#ffffff\u0026#34;; const snakeColor = \u0026#34;#53b096\u0026#34;; const snakeBorder = \u0026#34;#000000\u0026#34;; const foodColor = \u0026#34;#d44444\u0026#34;; 声明其他变量：\nconst unitSize = 25; let running = false; let score = 0; unitSize是游戏中的单位，不管是一个食物格的大小，还是贪吃蛇的一个身体部位的大小，包括贪吃蛇移动的速度，都会以unitSize为单位，这里设置为25px。 running表示游戏是否正在运行的状态。 score表示游戏的分数。 声明移动速度：\nlet xVelocity = unitSize; let yVelocity = 0; xVelocity表示每个游戏单位时间x轴移动的速度。 如果xVelocity是正数，贪吃蛇向右移动；如果是负数，贪吃蛇向左移动。 一开始设置为一个unitSize，表示向右移动一个unitSize单位。 yVelocity表示每个游戏单位时间y轴移动的速度。 如果yVelocity是正数，贪吃蛇向下移动；如果是负数，贪吃蛇向上移动。 一开始设置为0，表示开始时即不向上移动也不向下移动。 声明食物格的坐标变量：\nlet foodX; let foodY; foodX是食物格在画布中的x坐标。 foodY是食物格在画布中的y坐标。 食物格的坐标会用函数createFood()随机生成。 声明一个对象数组表示贪吃蛇：\nlet snake = [ {x:unisize * 4, y:0}, {x:unisize * 3, y:0}, {x:unisize * 2, y:0}, {x:unisize, y:0}, {x:0 y:0}, ] 定义初始贪吃蛇的长度是5格。 每个对象中的属性是贪吃蛇身体每个部分在画布中的x坐标和y坐标。 声明完变量后，我们给windows窗口添加addEventListner监听键盘事件，监听←↓↑→方向键是否被按下。如果监听到方向键被按下，则执行changeDirection()函数改变贪吃蛇移动的方向，这个函数会在稍后被定义。\nwindow.addEventListener(\u0026#34;keydown\u0026#34;, changeDirection); 给restartBtn按钮添加addEventListener监听鼠标事件，当按钮被点击时，执行restartGame()函数，在稍后也会被定义。\nrestartBtn.addEventListener(\u0026#34;click\u0026#34;, restartGame); 调用开始游戏的函数startGame()，稍后定义。\nstartGame(); 解下来定义我们所有需要的函数。\nThe startGame function # function startGame(){ running = true; scoreDisplay.textContent = score; createFood(); drawFood(); nextTick(); } 设置运行状态running为true，表示游戏开始。 将页面上的游戏分数更改为当前获得的游戏分数。 依次调用createFood()和drawFood()和nextTick()函数。 The nextTick function # nextTick()是每个游戏时间单位都会做的事情。\nfunction nextTick(){ if(running){ setTimeout(() =\u0026gt;{ clearBoard(); drawFood(); moveSnake(); drawSnake(); checkGameOver(); nextTick(); }, 75) } else{ displayGameOver(); } } 如果游戏正在进行，设置75毫秒后会做的事情：清除画布，绘制食物格，移动贪吃蛇，绘制贪吃蛇，检查游戏是否结束，再调用一次nextTick()函数，这样就能不断重复这些过程，并在游戏结束时停下。 如果游戏停止，则在页面上提醒游戏结束。 The clearBoard function # clearBoard()函数用于重画画布。\nfunction clearBoard(){ context.fillStyle = boardBackground; context.fillRect(0, 0, gameWidth, gameHeight); } fillStyle设置画布的填充颜色。 fillRect(x,y,width,height)绘制一个画布，从坐标（0,0)开始，宽度和高度都是画布的宽度和高度。 The creatFood function # createFood会随机在画布中找到一个位置放置食物格。\nfunction createFood(){ function randomFood(min, max){ const randNum = Math.round((Math.random() * (max - min) + min) / unitSize) * unitSize; return randNum; } foodX = randomFood(0, gameWidth - unitSize); foodY = randomFood(0, gameWidth - unitSize); } 定义一个内嵌函数randomFood生成能被unitSize整除的随机数。 (Math.random() * (max - min) + min)会生成在min到max之间的随机数； 这个Math.round()取得这个随机数除以unitSize的整数，得到这个随机数一共有多少个UnitSize； 此时再乘以UnitSize，就会得到范围在min~max之间，并且无论如何都会被unitSize整除的随机数。 食物格x轴的范围是0～gameWidth - unitSize，y轴也一样。 分别随机生成食物格x轴的值与y轴的值，得到食物格的位置。 The drawFood function # drawFood会在游戏画布中绘制出食物格。\nfunction drawFood(){ context.fillStyle = foodColor; context.fillRect(foodX, foodY, unitSize, unitSize); } fillStyle设置图形的填充颜色。 fillRect(x,y,width,height)绘制一个方形，食物格的x轴与y轴，在createFood()函数中已经随机生成，食物格的宽度和高度都会是一个unitSize。 The moveSnake function # 移动贪吃蛇的思路是：在贪吃蛇的移动方向创建一个贪新的头部方块，并消除尾巴方块，这样看起来就像在移动一样。\nfunction moveSnake(){ const head = {x: snake[0].x + xVelocity, y: snake[0].y + yVelocity}; snake.unshift(head); if(snake[0].x == foodX \u0026amp;\u0026amp; snake[0].y == foodY){ score++; scoreDisplay.textContent = score; createFood(); } else{ snake.pop(); } } 创建一个新的头部方块并用Array.unshift()方法向数组的开头添加该头部。 判断贪吃蛇是否吃掉了食物格，如果贪吃蛇头部的坐标和食物格的坐标重合，那么就是吃掉了食物格。此时将游戏分数加1，并再创建一个食物。 如果没有吃掉食物格，那么贪吃蛇在移动，用Array.pop()会删除数组的最后一个元素，在这里，就是删除贪吃蛇的尾巴方块。 The drawSnake function # function drawSnake(){ context.fillStyle = snakeColor; context.strokeStyle = snakeBorder; snake.forEach(snakePart =\u0026gt; { context.fillRect(snakePart.x, snakePart.y, unitSize, unitSize); context.strokeRect(snakePart.x, snakePart.y, unitSize, unitSize); }) } 因为snake是一个数组对象，用forEach遍历贪吃蛇的每一个身体部位，并画出方块与边框。 The changeDirection function # function changeDirection(event){ const keyPressed = event.keyCode; const LEFT = 37; const UP = 38; const RIGHT = 39; const DOWN = 40; const goingUp = (yVelocity == -unitSize); const goingDown = (yVelocity == unitSize); const goingRight = (xVelocity == unitSize); const goingLeft = (xVelocity == -unitSize); switch(true){ case (keyPressed == LEFT \u0026amp;\u0026amp; !goingRight): xVelocity = -unitSize; yVelocity = 0; break; case (keyPressed == UP \u0026amp;\u0026amp; !goingDown): xVelocity = 0; yVelocity = -unitSize; break; case (keyPressed == RIGHT \u0026amp;\u0026amp; !goingLeft): xVelocity = unitSize; yVelocity = 0; break; case (keyPressed == DOWN \u0026amp;\u0026amp; !goinUp): xVelocity = 0; yVelocity = unitSize; break; } } keyCode表示键盘上的按键键的键码值，keyPressed存储当前按下的按键的键码值。方向键的键码值分别是： ←: 37 ↑: 38 →: 39 ↓: 40 用描述性的语言LEFT、UP、RIGHT、DOWN存储这些键码值。 goingUp、goingDown、goingRight、goingLeft返回的是布尔值。 判断keyPressed == LEFT \u0026amp;\u0026amp; !goingRight的目的是保证按下左方向键←后，可以继续向左向上或向下，当不能向右，因为向右将咬到自己输掉游戏。 The checkGameOver function # 游戏结束有两种情况，一种情况是，贪吃蛇碰到游戏的边框，第二种情况是贪吃蛇咬到自己。\nfunction checkGameOver(){ switch(true){ case (snake[0].x \u0026lt; 0): running = false; break; case (snake[0].x \u0026gt;= gameWidth): running = false; break; case (snake[0].y \u0026lt; 0): running = false; break; case (snake[0].y \u0026gt;= gameHeight): running = false; break; } for(let i = 1; i \u0026lt; snake.length; i++){ if(snake[i].x == snake[0].x \u0026amp;\u0026amp; snake[i].y == snake[0].y){ running = false; } } } 用switch条件语句判断是否碰到游戏画布的边框： 当贪吃蛇头部的x坐标小于0，说明贪吃蛇碰到了左边的边框，结束游戏。 当贪吃蛇头部的x坐标大于画布的宽度，说明贪吃蛇碰到了右边的边框，结束游戏。 当贪吃蛇头部的y坐标小于0，说明贪吃蛇碰到了上面的边框，结束游戏。 当贪吃蛇头部的y坐标大于画布的高度，说明贪吃蛇碰到了下面的边框，结束游戏。 用for循环遍历贪吃蛇身体的每个部分，判断贪吃蛇的头部是否与身体的任何一个部分重合。 The display GameOver function # 在游戏的中间显示“GAME OVER!”\nfunction displayGameOver(){ context.font = \u0026#34;50px Shantell Sans\u0026#34;; context.fillStyle = \u0026#34;black\u0026#34;; context.textAlign = \u0026#34;center\u0026#34;; context.fillText(\u0026#34;GAME OVER!\u0026#34;, gameWidth / 2, gameHeight /2); running = false; } The restartGame function # function restartGame(){ score = 0; xVelocity = unitSize; yVelocity = 0; snake = [ {x:unitSize * 4, y:0}, {x:unitSize * 3, y:0}, {x:unitSize * 2, y:0}, {x:unitSize, y:0}, {x:0, y:0}, ]; startGame(); } 将游戏分数和移动速度重置为0。 重新创建一个snake。 调用开始游戏startGame()函数。 到此为止，已经成功写出基本的贪吃蛇游戏了。\n结语 # 发现贪吃蛇能很好的练习HTML5的Canvas，和JavaScript的DOM与事件，值得反复练习。\nReference # A game of Snake written in JavaScript 🐍 ","date":"2023-03-08","permalink":"/project/how-to-build-a-snake-game-in-javascript/","section":"Projects","summary":"JavaScript的练习项目，实现贪吃蛇游戏。","title":"如何用JavaScript实现贪吃蛇游戏"},{"content":"在这篇文章中会展示如何用JavaScript实现一个秒表计时器，这是我在学习JavaScript过程中的一个练习项目，接下来的内容也只是我作为初学者在练习过程中的理解。\n在一个秒表计时器(stop watch)中会有开始计时，暂停计时，与重置时间的功能，同时，我们希望在暂停计时后，还能从当前位置继续计时，接下来将实现这些功能。\nLive Demo: https://mia-stop-watch.netlify.app/ Source Code: https://github.com/miawithcode/stop-watch Prerequisite # 这篇博文假设你已经学过JavaScript中的：\nDate Object DOM Arrow Function（箭头函数） Callback （回调函数） addEventListener() setInterval() \u0026amp; setTimeout() Math.floor() Date.now() # 在开始写代码前，先了解Date Object中的Date.now()方法。\nDate.now()是写在JavaScript内嵌对象Date中的方法，表示从纪元时间(UTC 1970/01/01)到现在经过的时间，返回以毫秒为单位的值。\n比如在写这篇文章的当下，Date.now()返回的值是：1677832655179，意味着从1970/01/01到现在一共流逝了1677832655179毫秒。\n下面是一个简单的例子：\nconst startTime = Date.now(); console.log(\u0026#34;开始计时\u0026#34;); setTimeout(() =\u0026gt; { const elapsedTime = Date.now() - startTime; elapsedTime = Math.floor(elapsedTime / 1000); console.log(`结束计时，用时： ${elapsedTime}`s, 2000) }) //Expected output: 结束计时，用时：2s 我们把【打印「开始计时」的时间】赋值给变量startTime，然后打印出“开始计时”。 用setTimeout()方法设置2秒后打印「结束计时」语句，同时打印出两条打印语句的间隔时间elapsedTime。 间隔时间elapsedTime等于【当前打印「结束计时」时的时间 Date.now()】减去【打印「开始计时」时的时间 startTime】 间隔时间elapsedTime应该为2s，因为setTimeout()设置的时间是2s。 理解了这个例子之后，我们会用这个·Date.now()方法表示计时器中涉及的时间。\nHTML # 我们从HTML开始，写出计时器中基本的文本与按钮。\n\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1 id=\u0026#34;timeDisplay\u0026#34;\u0026gt;00:00:00:00\u0026lt;/h1\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; id=\u0026#34;startBtn\u0026#34;\u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; id=\u0026#34;pauseBtn\u0026#34;\u0026gt;Pause\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; id=\u0026#34;resetBtn\u0026#34;\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 使用了一些非常基础的HTML标签：\n用一级标题\u0026lt;h1\u0026gt;来显示页面上的时间：00:00:00:00 用三个按钮\u0026lt;button\u0026gt;分别用于start（开始计时），pause（暂停计时），reset（重置时间）。 目前我们不关心CSS样式，只关心计时器的实现，你可以按照自己的喜好设计计时器，接下来用JavaScript实现计时器的功能。\nJavaScript # 首先，声明我们需要的变量：\nconst timeDisplay = document.querySelector(\u0026#34;#timeDisplay\u0026#34;); const startBtn = document.querySelector(\u0026#34;#startBtn\u0026#34;); const pauseBtn = document.querySelector(\u0026#34;#pauseBtn\u0026#34;); const resetBtn = document.querySelector(\u0026#34;#resetBtn\u0026#34;); let startTime = 0; let elapsedTime = 0; let paused = true; let intervallId; let hours = 0; let minutes = 0; let seconds = 0; let miliseconds = 0; document.querySelector选择的是4个HTML中的元素（Element），一级标题和三个按钮。 startTime与elapsedTime分别表示开始时间与间隔时间。 开始时间startTime有两种，一种是从 00:00:00:00 开始计时的时间，另一种是暂停后继续计时的开始时间。 间隔时间elapsedTime也有两种，一种是setInterval()设置的间隔时间，另一种是暂停后继续计时中暂停了多久的间隔时间。 paused是一个布尔值，用于判断当前程序是暂停了，还是正在运行。在一开始时，把paused设置成false。 intervalId是setInterval()这个timer的id，一开始只声明不赋值。 hours, minutes, seconds, miliseconds分别代表 00:00:00:00 中各自的单位。 The start button # 然后我们实现开始计时的功能：\nstartBtn.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { if(paused){ paused = false; startTime = Date.now() - elapsedTime; intervalId = setInterval(updateTime, 75); } }) 给开始计时的按钮startBtn添加点击事件，设置点击开始计时的按钮后会执行的程序。 检查暂停状态paused是否为true，如果程序是暂停的，则将暂停状态paused设置成false，表示计时器是开启的状态。 开始计时的时间startTime会等于现在的时间Date.now()减去间隔时间elapsedTime 因为接下来会用setInterval设置一个重复定时调用的函数，比如每隔1000毫秒调用一次函数，此时的1000毫秒就是elapsedTime。 最开始的elapsedTime我们在声明变量时已经设置成0; 用setInterval()设置每隔75毫秒调用一次updateTime()函数。 The updateTime function # 接下来定义updateTime()函数：\n我们先看最基础的逻辑，updateTime()到底要实现什么：\nfunction updateTime(){ elapsedTime = Date.now() - startTime; miliseconds = Math.floor(elapsedTime % 1000); seconds = Math.floor(elapsedTime / 1000 % 60); minutes = Math.floor(elapsedTime / 1000 / 60 % 60); hours = Math.floor(elapsedTime / 1000 / 60 / 60 % 60); timeDisplay.textContent = `${hours}:${minutes}:${seconds}:${miliseconds}`; } 间隔时间elapsedTime等于现在的时间Date.now()减去开始计时的时间startTime。而这个间隔时间就是我们显示在页面上的时间。 举个例子，我从8:30开始计时，现在的时间是8:35，一共过去了5分钟，那么现在计时器上的时间就应该是5分钟。 由于Date.now()返回的是以毫秒为单位的值，那么计算出的间隔时间elapsedTime的单位也是毫秒数，我们要把它格式化成00:00:00:00的形式 由于1000毫秒等于1秒，那么每过1000毫秒，秒数就会增加1秒，而毫秒位会归零重新计数，所以用变量miliseconds等于elapsedTime取余%1000的值。秒数，分钟数，时钟数也是这个思路去格式化。 将格式化后的elapsedTime显示在HTML页面上。但是此时会有一个问题：在显示时，秒数、分钟数、时钟数有1位数和2位数的情况，我们希望当它们是1位数时，前面会有1个0来组成2位数。 我们在updateTime()函数中写一个内嵌函数formatTime()，当秒数、分钟数、时钟数是1位数时，在前面添加一个0：\nfunction formatTime(unit){ return ((\u0026#34;0\u0026#34;) + unit).length \u0026gt; 2 ? unit : \u0026#34;0\u0026#34; + unit; } formatTime()函数接受一个时间单位作为参数， 判断当\u0026quot;0\u0026quot;加上一个时间单位时，这个时间单位的字符串长度是否大于2。 如果\u0026quot;0\u0026quot; + unit的字符串长度大于2，说明这是一个2位数的时间单位，只需要返回这个时间单位； 如果\u0026quot;0\u0026quot; + unit的字符串小于2，说明这是一个1位数的时间单位，返回\u0026quot;0\u0026quot; + unit。 在formateTime()我们没有考虑miliseconds的情况，因为它最多可以有3位数，我们用一个formatMili()来单独实现毫秒的格式化：\nfunction formatMili(unit){ unit = String(unit); switch(unit.length){ case 1: return \u0026#34;0\u0026#34; + unit; break; case 2: return unit; break; case 3: return unit.slice(0, 2); break; } } 首先将数字类型的miliseconds类型转化为字符串类型，这样才能用String.length来判断毫秒数是几位数。 用switch条件语句分别判断当毫秒数是1位数、2位数、3位数时的情况。 完整的updateTime()函数的代码是：\nfunction updateTime(){ elapsedTime = Date.now() - startTime; miliseconds = Math.floor(elapsedTime % 1000); seconds = Math.floor(elapsedTime / 1000 % 60); minutes = Math.floor(elapsedTime / 1000 / 60 % 60); hours = Math.floor(elapsedTime / 1000 / 60 / 60 % 60); miliseconds = formatMili(miliseconds); seconds = formatTime(seconds); minutes = formatTime(minutes); hours = formatTime(hours); timeDisplay.textContent = `${hours}:${minutes}:${seconds}`; function formatTime(unit){ return ((\u0026#34;0\u0026#34;) + unit).length \u0026gt; 2 ? unit : \u0026#34;0\u0026#34; + unit; } function formatMili(unit){ unit = String(unit); switch(unit.length){ case 1: return \u0026#34;0\u0026#34; + unit; break; case 2: return unit; break; case 3: return unit.slice(0, 2); break; } } } The pause button # pauseBtn.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { if(!paused){ paused = true; elapsedTime = Date.now() - startTime; clearInterval(intervalId); } }) 给暂停计时的按钮添加点击事件，设置点击暂停计时的按钮后会执行的程序。 检查现在是否不是处于暂停状态，即是否是正在计时的状态，如果是，则将paused设置成true，表示现在是暂停状态。 计算暂停了多长时间eplasedTime 调用clearInterval终止setInterval()设置的重复定时任务，即停止更新页面上的时间。 The reset button # 重置时间是一个比较简单的功能，重置就是把所有状态恢复到最开始的状态。\nresetBtn.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { paused = true; clearInterval(intervalId); startTime = 0; elapsedTime = 0; hours = 0; minutes = 0; seconds = 0; miliseconds = 0; timeDisplay.textContent = \u0026#34;00:00:00:00\u0026#34;; }) 把暂停状态paused设置成true，因为现在没有在计时。 调用clearInterval终止setInterval()设置的重复定时任务，即停止更新页面上的时间。 把所有变量重新设置为0 将HTML的文本重新设置为00:00:00:00 到此为止，一个秒表计时器的功能已经全部实现。\n结语 # 这个project我在学习的时候有很多地方卡壳想不明白，写完这篇博文后发现思路其实非常清晰，看来「The best way of learning is teaching.」is so damn true\nReference # Date.now()的解释 - Mozilla A stopwatch written in JavaScript ⏱️ ","date":"2023-03-07","permalink":"/project/how-to-build-a-stop-watch-in-javascript/","section":"Projects","summary":"JavaScript的练习项目，实现开始计时，暂停计时，和重置时间的功能。","title":"如何用JavaScript实现秒表计时器"},{"content":"","date":"2022-10-18","permalink":"/tags/github-pages/","section":"Tags","summary":"","title":"github pages"},{"content":"","date":"2022-10-18","permalink":"/tags/tutorial/","section":"Tags","summary":"","title":"tutorial"},{"content":"根据 GitHub Pages 官网介绍，一个GitHub账号只能拥有一个 GitHub Pages 网站，但该账号可以拥有无限的项目 GitHub Pages 网站。当仓库中已经有一个\u0026lt;username\u0026gt;.github.io时，要如何为项目创建 GitHub Pages？\n答案是：在项目仓库中建立gh-pages分支。\n1. 在本地创建空的 gh-pages 分支 # 以Hugo建站为例，Hugo生成的所有 html 文件会储存在 public 文件夹中，所以只需将 public 文件夹中的内容上传至 gh-pages 分支并部署。\n# 进入要上传的文件夹 cd public # 将文件夹初始化为 git 仓库，设置主分支为 main git init -b main #创建 gh-pages 分支，并切换到 gh-pages 分支 git checkout --orphan gh-pages 2. 推送 public 文件中的内容至 gh-pages # #将文件提交到暂存区并提交 git 修改信息 git add . git commit -m \u0026#34;...（信息）\u0026#34; #连接远程仓库(仓库的 SSH 链接) git remote add origin git@github.com:username/repository.git #将 `public` 文件夹中的内容推送至远程仓库 git push origin gh-pages 3. 部署项目至 gh-pages 分支 # 做完这一步就大功告成了，如果你没有为项目设置自定义域名，接下来可以在 https://\u0026lt;username\u0026gt;/repository.github.io 看到刚刚部署的项目内容。\nReference # GitHub Pages 官网 在github上建立gh-pages分支 Related Posts # 如何用 GitHub Pages + Hugo 搭建个人博客 ","date":"2022-10-18","permalink":"/blog/deploy-project-to-gh-pages/","section":"Blog","summary":"介绍当仓库中已经有一个 \u003ccode\u003e\u0026lt;username\u0026gt;.github.io\u003c/code\u003e 仓库时，如何创建\u003ccode\u003egh-pages\u003c/code\u003e分支来为项目设置 GitHub Pages。","title":"如何给项目设置 GitHub Pages"},{"content":"","date":"2022-09-02","permalink":"/tags/github/","section":"Tags","summary":"","title":"github"},{"content":"SSH(Secure Shell)是允许两台电脑之间通过安全连接进行数据交换的网络协议。\n在本地电脑生成SSH Key私钥，再将SSH Key公钥添加到GitHub，就实现了本地电脑和GitHub服务器安全连接，可以把本地仓库推送到GitHub远程仓库，或把GitHub远程仓库拉取到本地仓库，即两台电脑间的数据交换。\nNoted：GitHub在2022年5月添加了SSH安全性，以往添加SSH Key的教程在有些细节处可能不适用，这是2022年下半年添加SSH Key的教程。\n1. 生成SSH Key # 点开 GitHub账号头像下的 Settings 找到 Settings 下的 SSH and GPG keys，点击 generating SSH keys，点击后会打开一个新的页面。 在新的页面中选择 Generating a new SSH key and adding it to the ssh-agent 注意选择对应操作系统的教程。 往下滑动页面会看到GitHub给出的Mac下生成SSH Key的指南，按照指南的步骤一步一步进行。 打开终端（Terminal），复制粘贴以下文本到终端，把 your_email@example.com 替换成你注册GitHub时使用的邮箱，然后按下Enter键。\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 如果你不记得注册GitHub时使用的邮箱，可以从 Settings 中的 Emails 中查看。 出现 Enter file in which to save the key(...) ，按下 Enter键，一直按 Enter 直到出现以下画面。 🎉 恭喜你的SSH Key已经生成成功，接下来把生成的SSH Key添加到ssh-agent。\n2. 添加SSH Key到ssh-agent # 在终端（Terminal）中输入命令： eval \u0026#34;$(ssh-agent -s)\u0026#34; 命令执行后终端会给出Agent pid 如果你使用的是 macOS Siera 10.12.2或以上的版本，你需要修改 ~/.ssh/config 文件来自动加载密钥到ssh-agent 和储存passphrases到你的钥匙链。\n首先，检查电脑中是否存在 ~/.ssh/config 文件 open ~/.ssh/config 如果像我一样显示这个config文件不存在，则创建这个文件 touch ~/.ssh/config\t用编辑器打开 ~/.ssh/config 文件 nano ~/.ssh/config 在nano窗口中复制粘贴以下代码： Host * AddKeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/id_ed25519 粘贴代码后按 control+X 退出编辑器 输入 y 保存更改 出现这个画面后再按 Enter 键\n将 SSH Key 添加到ssh-agent。如果你使用的是 Mac Monterey(12.0)及以上版本，请使用以下命令（因为在Mac Monterey(12.0)及以上版本中，-K 标志已经被废弃，被 --apple-use-keychain 代替）。\nssh-add --apple-use-keychain ~/.ssh/id_ed25519 如果不是Mac Monterey(12.0)及以上版本，使用以下命令： ssh-add -K ~/.ssh/id_ed25519 🎉 出现 Identity added 即表示添加成功。 3. 添加SSH Key到GitHub # 在终端输入以下命令， pbcopy 会复制SSH Key内容到剪贴板 pbcopy \u0026lt; ~/.ssh/id_ed25519.pub 再次打开GitHub Settings 下的 SSH and GPG Key ，点击 New SSH key 添加本机生成的SSH Key到GitHub： 在Title中给这个SSH Key命名 Key Type选择 Authentication Key 在Key中 Command+V 粘贴刚刚复制的SSH Key 添加后点击 Add SSH Key 。 🎉 添加完成。 4. 测试SSH Key是否添加成功 # 选择一个要用SSH Key clone的仓库，复制这个仓库的SSH链接。 在终端输入: git clone [ssh-url] 🎉 clone成功即代表SSH Key添加成功。 Reference # How to Set Up an SSH Key to GitHub on Mac ","date":"2022-09-02","permalink":"/blog/how-to-add-ssh-key-to-github-on-mac/","section":"Blog","summary":"介绍如何在Mac上生成一个SSH Key，生成之后将SSH Key添加到自己的GitHub账号中，以便通过SSH对Git操作进行认证。","title":"如何在 Mac 上为 GitHub 设置SSH Key（2022）"},{"content":"","date":"2022-08-29","permalink":"/tags/hugo/","section":"Tags","summary":"","title":"hugo"},{"content":" 1. 概念，搭建思路和运行环境 # 1.1 什么是GitHub Pages？ # GitHub Pages 是一组静态网页集合(Static Web Page)，这些静态网页由 GitHub 托管(host)和发布，所以是 GitHub + Pages。\n1.2 什么是Hugo？ # Hugo 是用Go语言写的静态网站生成器(Static Site Generator)。可以把Markdown文件转化成HTML文件。\n1.3 网站搭建思路 # 创建2个GitHub仓库 博客源仓库：储存所有blog内容，以及blog中用到的图片等等 GitHub Pages仓库：将网页部署在GitHub Pages 将在博客源仓库中Hugo生成的静态HTML文件部署到远端GitHub Pages仓库中。 1.4 运行环境 # 这篇教程假设你已经： 了解基本的终端命令行知识，如：cd, ls 安装了 Git，并且了解基本的Git知识 有一个 GitHub账号 有自己偏好的代码编辑器（我使用的是 VS Code） 2. 安装Hugo # 这里使用包管理器安装 Hugo，我的操作系统是 Mac OS，所以使用 Homebrew 安装Hugo。如果你使用的是 Windows 或 Linux，可以根据 Hugo 文档提示的方式安装： Hugo文档：Install Hugo\nbrew install hugo 查看Hugo是否安装成功，显示Hugo版本号代表Hugo安装成功。\nhugo version 3. 创建GitHub仓库 # 3.1 创建博客源仓库 # 命名博客源仓库（whatever you want） 勾选Public，设置为公开仓库。 勾选添加README文件 3.2 创建GitHub Page仓库 # 命名GitHub Pages仓库，这个仓库必须使用特殊的命名格式 \u0026lt;username.github.io\u0026gt;， \u0026lt;username\u0026gt; 是自己的GitHub的用户名。 勾选Public，设置为公开仓库。 勾选添加README文件，这会设置 main 分支为仓库的默认主分支，这在后面提交推送博客内容时很重要。 4. 克隆博客源仓库到本地 # 打开想要在本地储存项目的文件夹（比如我的项目的文件夹是 project ）\ncd project 克隆博客源仓库到项目文件夹，克隆时使用的HTTPS仓库链接在这里查看： git clone https://github.com/miawithcode/cuttontail.git 5. 使用Hugo创建网站 # 进入刚刚克隆下来的博客源仓库文件夹（比如：我的博客源仓库文件夹名是 cuttontail，则cd cuttontail ），在这个文件夹里用Hugo创建一个网站文件夹。\n用Hugo创建网站文件夹的命令是 hugo new site 网站名字。(比如，我的命名是 cuttontail-blog)\ncd cuttontail hugo new site cuttontail-blog 用Hugo创建的网站共有7个文件夹和1个文件，这些文件分别代表： archetypes：存放用hugo命令新建的md文件应用的front matter模版 content：存放内容页面，如Blog layouts：存放定义网站的样式，写在layouts文件下的样式会覆盖安装的主题中的 layouts文件同名的样式 static：存放所有静态文件，如图片 data：存放创建站点时Hugo使用的其他数据 public：存放Hugo生成的静态网页 themes：存放主题文件 config.toml：网站配置文件 6. 安装和配置Hugo主题 # 6.1 选择Hugo主题 # 可以从 Hugo社区提供的主题中选择一个喜欢的主题应用在自己的网站中。\n6.2 安装Hugo主题 # 一般在你选择的Hugo主题的文档中，都会给出「如何安装这个主题」的命令，比如我选用的 Hugo Bear Blog 的文档中给出：\n打开刚刚用Hugo创建的网站文件夹（我的是cuttontail-blog），在终端输入文档中给出的命令。 这时可以看到在themes文件夹中，多出了刚刚安装的主题文件，代表主题安装成功。 6.3 配置Hugo主题 # 一般安装的Hugo主题的文件结构中都会有 exampleSite 文件夹，也是你在选择主题时参考的网站demo。\n把 exampleSite 的文件复制到站点目录，在此基础上进行基础配置。 非常推荐这么做，这样做能解决很多「为什么明明跟教程一步一步做下来，显示的结果却不一样？」的疑惑。（这主要是因为不同的主题模版配置文件不同导致的。）\n在把exampleSite文件复制到站点目录时，根据对应文件夹进行复制文件\n比如exampleSite下有 content , static 和 config.toml 3个文件，就找到你自己的站点跟目录下这对应的三个文件。在把对应目录中的内容分别复制过去。 其中在复制config.toml的内容时要注意：\nbaseURL baseURL = \u0026#34;https://example.com/\u0026#34; #把https://example.com/改成自己的域名\t如果你没有在GitHub Pages中设置自定义域名，这里的域名应该填 https://\u0026lt;username\u0026gt;.github.io/ （⚠️注意：最后的/不要忘了加） themes themes = \u0026#34;你选择的主题名字\u0026#34;。 #这一行命令代表启用你安装的主题 在 config.toml 中输入这行命令才能启用安装的主题，不过一般这行命令在你复制 exampleSite 的配置文件信息时，主题作者已经写好了这行。 7. 用Hugo创建文章 # 用Hugo创建一篇文章的命令是:\nhugo new xxx.md 用这个命令创建的Markdown文件会套用 archetypes 文件夹中的front matter模版，在空白处用Markdown写入blog内容。 其中：draft: true代表这篇文章是一个草稿，Hugo不会显示草稿，要在主页显示添加的文章，可以设置 draft: false；或者直接删掉这行。\n8. 本地调试和预览 # 在发布到网站前可以在本地预览网站或内容的效果，运行命令： hugo server 也可以在本地编辑Markdown文件时，通过 hugo server 来实时预览显示效果。 hugo server 运行成功后，可以在 http://localhost:1313/ 中预览网站 9. 发布内容 # hugo 命令可以将你写的Markdown文件生成静态HTML网页，生成的HTML文件默认存放在 public 文件夹中。\nhugo 因为hugo 生成的静态HTML网页文件默认存放在 public 文件中，所以推送网页内容只需要把 public 中的HTML网页文件发布到GitHub Pages仓库中。\n将 public 文件夹初始化为Git仓库，并设置默认主分支名为 main。这么做的原因是：\nGitHub创建仓库时生成的默认主分支名是 main 用 git init 初始化Git仓库时创建的默认主分支名是 master 将 git init 创建的 master 修改成 main ，再推送给远端仓库 \u0026lt;username\u0026gt;.github.io ，这样才不会报错。 cd public git init -b main 将 public 文件夹关联远程GitHub Pages仓库，使用GitHub Pages仓库的SSH链接。\n（ ⚠️ 注意：要让SSH链接起作用，需要你添加过SSH Key。如果你没有设置SSH Key，请参考 如何在Mac上为GitHub设置SSH Key）\nGitHub Pages仓库的SSH链接可以在这里查看： git remote add origin git@github.com:miawithcode/miawithcode.github.io.git 推送博客源仓库的 public 文件夹中的HTML网页文件到GitHub Pages仓库中，在推送仓库内容前要先用 git pull --rebase origin main 和远端仓库同步，否则会报错。\ngit pull --rebase origin main git add . git commit -m \u0026#34;...(修改的信息)\u0026#34; git push origin main 转到GitHub中查看GitHub Pages仓库中是否存在刚刚推送的文件，存在则代表推送成功。 如果你没有设置自定义域名，且把 comfig.toml 文件中的 baseURL 设置为 https://\u0026lt;username\u0026gt;.github.io，就可以在 https://username.github.io 中查看刚刚创建的网站。 ( 👀 我使用的是自定义域名，所以这里用我的自定义域名查看。) 后续的更新步骤：\n创建你的文章.md 用 hugo server 在本地预览，满意后准备发布。 运行 hugo 命令将Markdown文件生成HTML文件。 将修改先提交至博客源仓库 git add . git commit -m \u0026#34;...(修改的信息)\u0026#34; git push 打开 public 文件 运行： git add . git commit -m \u0026#34;...(修改的信息)\u0026#34; git pull --rebase origin main #可选,如果远端仓库与本地一致，则不需要合并。 git push origin main 如果你使用的是自定义域名，第一次推送成功后，GitHub Pages 仓库会生成CNAME文件，所以第二次推送还要再合并一次：git pull --rebase origin main。后续的更新Blog就不再需要使用这个命令了。（根据实际情况使用） 发布内容除了手动发布，还能使用GitHub Action自动发布。但我认为刚刚搭建好一个网站，立刻就用GitHub Action有些Overwhelming，先手动发布，熟练之后再开始使用GitHub Action自动发布会比较好。\nReference # Creating a Blog with Hugo and Github in 10 minutes Hugo + GitHub Action，搭建你的博客自动发布系统 Hugo - Quick Start ","date":"2022-08-29","permalink":"/blog/create-a-wesite-using-github-pages-and-hugo/","section":"Blog","summary":"介绍如何使用一个博客源仓库和一个GitHub Pages仓库，使用 GitHub Pages 和 Hugo 無料搭建个人博客。","title":"如何用 GitHub Pages + Hugo 搭建个人博客"},{"content":" Now 页面会随着时间和当下生活的优先级而更新，用来让别人看见这个人现在生活的重点是什么，和提醒自己专注于当下最重要的事。 正在做 # 通过 JavaScript Info复习JavaScript ","date":"2022-08-14","permalink":"/now/","section":"小綿尾巴","summary":" Now 页面会随着时间和当下生活的优先级而更新，用来让别人看见这个人现在生活的重点是什么，和提醒自己专注于当下最重要的事。 正在做 # 通过 JavaScript Info复习JavaScript ","title":"Now"},{"content":"","date":"2022-08-12","permalink":"/tags/create/","section":"Tags","summary":"","title":"create"},{"content":" 为自己创作 # 哲学家Alan Watts认为自己是“从山边冒出的泉水” — 如果路人喝了泉水并且很享受，这很好，但这不是泉水的目的。\n泉水只是存在。(The spring just exists.)\nAli Abdaal 引用这个例子来说明他对创作的态度：是为了自己写作和拍视频，如果这帮助到了一个人，是一个很棒的附加奖励，但这并不是写作和拍视频的目的。\n只有为自己创作后，才能创作自己想创作的东西，想什么时候创作就什么时候创作，这称为创作自由。\n其中有趣的地方是，Ali在鼓励新手创作者，说明他们可以创造什么内容时说到：要创造至少对世界上的一个人有帮助的东西。\n这个矛盾的地方是不是可以这么理解：以「创造对别人有用的的东西」为目的只是为一开始的探索期提供灵感，提供内容；当你在探索过程中逐渐得心应手，明白自己想创作什么时，就不必局限在必须为别人创作点什么的想法里，开始以「为自己创作」为目的，才能拥有创作自由，成为那个只是存在着的泉水。\n刚开始创作时：创造至少对世界的上一个人有帮助的东西。 创作得心应手后：为自己创作，对别人有帮助是副加的奖励。 David Perell的观点是要为自己写作，或者为一个你想吸引的那类读者的一个代表人物写作。\nDavid Perell强调不要为一群人写作，因为那会让你感到不知所措，只为一个人写作，不管是为你自己，还是为一个想吸引的读者的代表人。\n为自己写作时：思考什么是6个月前的自己想要知道的事，专注于那个会让自己感到惊喜的想法。\n为他人写作时：可以在文章的开头写下你想吸引的那类读者的特点，比如：凯文阅读信息的速度非常快，他是一个科技公司的创始人，他对严谨思考的渴望和对空洞想法的不耐烦一样，所以赶紧说重点。\n这对我的启发是，写文章的初心是为自己写，当意识到正在写的东西可能会对一个人有帮助时，要想着这个人去写，就像在酒吧和朋友对话一样，尊重对方，用自然流畅的语言表达你的观点。\n不要只是为自己创作 # 「不要只是为自己创作」是从另一个角度切入的，从是私人写作还是公开写作出发。\n当你在私下写作，这没有为自己写作还是为他人写作之分，私下写作是为自己写作，可能是对过去的自己反思，也可能是对未来的自己喊话。\nDavid Perell认为不要只是为自己写作，要把你的文章发布在网上。公开写作就像是请朋友到家里做客一样，你会打扫干净你的房间，仔细检查要准备的所有东西。就像你为客人做饭一样，当别人在看着你，你的名誉可能受到威胁时，你会更加努力，社交压力会迫使你提高自己的水平。\n总结 # 公开写作，不要私下写作。 没有创作灵感时，写对他人有帮助的内容，心里想着那一个你想吸引的读者，为他/她创作。 有创作灵感时，为自己创作（也可以为一个人创作），写自己感兴趣的内容，找到创作自由。 Related Posts # How to Find Creative Freedom Write for One Person 独立博客过时以后，为什么开始写博客了？ ","date":"2022-08-12","permalink":"/blog/create-for-whom/","section":"Blog","summary":"在内容创作上，应该以「创造至少对世界上的一个人有帮助的东西」这样的心情去创作，还是以「为自己创造，让帮助到别人这件事成为附加奖励」的心情去创作呢\u0026hellip;","title":"创作者应该为谁创作？寻找创作自由"},{"content":" 《掌控习惯》这本书主要回答2个问题：\n如何设计你的生活，让好习惯更容易养成？ 如何戒除你一直想戒除的坏习惯？ 《掌控习惯》的英文原名是 Atomic Habits，掌控习惯是一种意译，因为Atomic的解释是原子的、微粒子的，没有掌控一意。原名 Atomic Habits 更契合作者在书中讲的微小的习惯在长时间内会有不可估量的影响。\n这篇包括这本书内容的简短总结，一些划线高亮和我认为如何把这些技巧应用到生活中的笔记。\n有一位YouTuber做的893万次播放量的总结也很值得回顾： How to become 37.78 times better at anything | Atomic Habits summary (by James Clear)\n以下是正文。\nChapter 1 - Chapter 3: 习惯的基本原理 # 1%的力量 # 进步1%：好习惯是自我提高的复利，因为习惯的效果会随着你不断地重复而倍增。\n要实现一个目标往往不是通过某个决定性时刻的正确做法，或者大规模的行动和重大转变的结果，而是通过每天进步1%的微小习惯。 一年365天，如果每天进步1%：（1+0.01）^365 = 37.78，一年后将比现在进步37倍。 退步1%：坏习惯是自我毁灭的复利。\n如果日复一日重复1%的错误：反复做出不良决策，重复微小的错误，为自己的小失误寻找借口，久而久之，小选择会叠加成有害的结果。 一年365天，如果每天退步1%：（1-0.01）^365 = 00.03，一年后现有的任何东西会降到几乎为0。 培养习惯的过程中，短期内甚至更长的时间里都看不到任何变化，这时候容易陷入失望而失去进步的动力，只有继续坚持每天1%的进步才能突破临界点，跨入新境界，突破时刻的出现通常是此前一系列行动的结果。\n忘记目标，专注体系。 # 如何让自己坚持足够长的时间，直到达到突破点：「忘记目标，专注体系。」 目标：想要达到的结果 体系：导致这些结果的过程 当你专注于建立和执行你的体系，你想要达成的结果会自然而然地达成。 目标的实现是一种延时的快乐，当你专注于体系，只要你创建的体系在正常运行，你就会在整个过程中感受到快乐。 行为改变的三个层次 # 行为转变的三个层次：结果的变化、过程的变化或和身份的变化。\n结果的变化：改变你的结果。你设定的大多数目标与这个层次的变化相关。 过程的变化：改变你的习惯和体系。你养成的大多数习惯与这个层次的变化相关。 身份的变化：改变你的身份。你持有的大多数信念、假设和偏见都与这个层次的变化相关。 结果意味着你得到了什么，过程意味着你做了什么，身份关系着你相信什么。\n在开始改变习惯时，不要基于最终目标养成习惯，要基于身份养成习惯。即不要专注于想要达成的目标，而要专注于我们希望成为什么样的人。\n真正的行为上的改变是身份的改变。你可能会出于某种动机而培养一种习惯，但让你长期保持这种习惯的唯一原因是它已经与你的身份融为一体。\n目标不是阅读一本书，而是成为读者。\n改变身份的2步过程 # 改变身份的2步过程 决定你想成为哪类人 不断重复成为这类人的行为证明给自己看 决定你想成为哪类人 从你想要的结果开始往回推，弄清楚什么样的人才能得到这些结果。 比如：能著书立说的是什么样的人？这个人可能具有专心致志、诚实可靠的品性。现在你的注意力就从写书（基于结果）转移到成为一个专心致志、诚实可靠的人（基于身份）。 不断重复成为这类人的行为证明给自己看 你的身份来自你的习惯。每个行动都是你在投票给你想成为的人。 你的习惯是体现你身份的方式。一种行为重复的次数越多，与之相关的身份就越是得以强化。你的习惯提供了塑造你身份的大部分证据。 你读了很多次书，你是一个读者的身份得到强化。 养成习惯的4步进程 # 养成习惯的过程可以分为四个简单的步骤：提示、渴求、反应和奖励。\n步骤 举例 提示 看到某一提示，想采取某一行动 看到烟想抽烟，烟是提示。 渴求 采取行动背后的欲望和动力 不是渴求抽烟，而是渴求吸烟带来的解脱感。 回应 将提示和渴求转化为实际行动 因为看到一支烟，想到吸烟能带来的解脱感，真的点了一根烟。 奖励 获得奖励是每个习惯的最终目标 吸了烟之后获得意料之中的满足感。 如果一种行为在这四个阶段中的任何环节做得不够，那么它就不会成为习惯。\n消除提示：你不会开始你的习惯 降低渴求：你没有动力去行动 回应困难：行动很难执行，你将无法付诸实施 奖励不能满足你的愿望：未来没有继续做的理由 习惯循环：提示触发渴求 =\u0026gt; 渴求激发反应 =\u0026gt; 反应提供渴求的奖励 =\u0026gt; 与提示关联\n根据养成习惯的四个步骤，如何培养好习惯与如何戒除坏习惯\n提示 渴求 回应 奖励 培养好习惯 让它显而易见 让它有吸引力 让它简单易行 让它令人愉悦 戒除坏习惯 使其无从显现 使其缺乏吸引力 使其难以施行 使其令人厌烦 Chapter 4 - Chapter 7: 第一定律 让它显而易见 # 将下意识习惯意识化 # 一种行为重复的次数多了以后，会变成一种下意识的习惯，而要改变一种习惯，就要把下意识意识化，保持警觉，知道我们实际在做什么。\n把下意识意识化的一个方法是习惯积分卡：\n列出日常习惯 用“+”好标注好习惯，“-”号标注坏习惯，“=”号标注中性习惯。 创建习惯积分卡后没必要改变任何东西，积分卡的目标只是提醒你注意实际发生的事情，帮助你了解你的行为。\n把下意识意识化的另一个方法是指差确认：识别，指出，大声说出事物的细节。\n在生活中进行指差确认，大声说出你想采取的行动和你预期的结果。 提醒待办的指差确认：大声说出“明天午饭后，我要去邮局”，就能提高你去的可能性。 戒除坏习惯的指差确认：比如你想戒掉吃垃圾食品的习惯，但注意到自己又拿起了一块饼干，你可以大声说：“我要吃这块饼干，但我并不需要它。吃掉它会导致我体重增加，损害我的健康。\n（说出坏习惯的后果让后果触手可及，增加了行动的难度。）\n明确执行习惯的方法 # 执行意图：事先制定何时何行动的计划。 执行意图的应用方式： 时间地点：我将在[时间]和[地点]做[事]。 习惯叠加：继[当前习惯]之后，我将[新习惯]。（让旧习惯成为触发新习惯的提示） 执行意图的好处： 明确执行的细节，消除心血来潮再去做这样模棱两可的说法，就何时、何处、具体做什么制定出具体计划后，就会更有可能贯彻执行。 将有助于你摒弃妨碍你进步、分散注意力，或让你偏离正轨的事情。 创建好习惯的提示显而易见的环境 # 每个习惯都是由提示引发的，我们更有可能注意到显眼的提示。 如果我们的环境充满触发习惯的显眼提示，我们更有可能去执行。 如果激发习惯动作的提示不起眼或隐藏起来时，它们很容易被忽略。 不要将你与环境的关系视作和一个个物体的关系，而是视作与一个个物体之间的关系集合的联系。 一种空间，一种用途：将一个特定的环境和特定的习惯联系起来。比如将沙发和看书这一行为联系起来，餐桌和吃饭这一行为联系，客厅和娱乐这一行为联系。也就意味着沙发上不能打游戏，餐桌上不能工作，客厅不能学习。 在全新的环境中习惯更容易改变。它有助于你远离原有容易促使你恢复旧习惯的触发提示。 创建坏习惯的提示脱离视线的环境 # 你可以改掉一个习惯，但你不太可能忘记它。当你处于易于触发这个习惯的环境中，本来改掉的习惯很可能卷土重来。 你可能能通过意志力短期地改掉坏习惯。但消除坏习惯的最实用的方法之一是避免接触引起它的提示。 Chapter 8 - Chapter 10: 第二定律 让它有吸引力 # 利用绑定喜好使习惯更有吸引力 # 在习惯循环（提示——渴求——回应——奖励）中，多巴胺不仅在获得奖励时分泌，在下一次循环中，在期待获得奖励时，也会分泌多巴胺。\n绑定喜好：把你需要做和愿意做的事绑定。（假如你在做一件事的同时得以做另一件你喜爱的事，那么前者很可能会对你产生一定的吸引力。）\n习惯叠加可以与绑定喜好结合：\n继[当前习惯]之后，我将[我需要的习惯。 继[我需要的习惯]之后，我将[我想要的习惯]。 比如：你特别想查看Facebook上的内容，但是你需要做更多的锻炼：\n在我掏出手机后，我要做十次立卧撑跳（需要）。 在我做了十次立卧撑跳之后，我将能查看脸书上的最新动态。 群体的吸引力 # 当某种行为有助于我们融入团体或社会时，它就具备了吸引力。 培养好习惯的最有效方式之一就是加入一种文化，在这种文化中，你偏爱的行为被认定为是正常行为。当你看到别人每天都这样做时，会觉得培养新习惯似乎并不难。 尽量和那些具备你想拥有的习惯的人在一起，你们会相互促进。 如何让高难度的习惯有吸引力 # 改变看待事情的方式，将负担视为机遇：你不是“得”而是“想”做那些事。Instead of I have to, I got to.\n别再对自己说“我需要一早去跑步”，而要说“是时候增强我的耐力、加快跑步速度了”。 激励仪式：把你的习惯和你喜欢的东西联系起来。\n将一个例行模式与心情愉悦的感受联系起来，比如深呼吸+微笑。 Chapter 11 - Chapter 14: 第三定律 让它简便易行 # 习惯是基于频率而不是基于时长形成的 # 想掌握一种习惯，关键是从重复开始，无需力求完美，只需要不断练习。 习惯的形成是一种行为通过重复变得越来越自动化的过程。自动化是指无须考虑每一个步骤而实施一种行为的能力。 最省力法则 # 在我们可能采取的所有行动中，最终被选择的行动一定是能以最小的努力获得最大价值的那一个。我们被激励着避重就轻，只做容易的事。 习惯坚持起来越难，你和你想要的最终状态之间的阻力就越大。 因减而加：寻找习惯中的每一个消耗时间和精力的阻力点，予以清除，取得事半功倍的效果。 同时可以增加坏习惯的阻力来戒除坏习惯。 2分钟法则 # 2分钟法则：当你开始培养一个新习惯时，它所用时间不应超过2分钟。 一个新习惯不应该让人觉得是挑战，2分钟法则的思路是让习惯尽可能容易开始。比如把“跑步3公里”变成“穿上跑鞋”。“穿上跑鞋”这个个动作只是用来引导你实现期望中结果的仪式。 不要指望从一开始就培养一种完美的习惯，要脚踏实地，连续不断地做些简单的事。先标准化，再优化。 Chapter 15 - Chapter 17: 第四定律 让它令人愉悦 # 人们享受到的快感会教给大脑，某种行为值得回忆和重复。 行为转变的基本规则：重复有即时回报的行为，避免受即使惩罚的行为。 增强法：利用及时奖励来提高行为频度。比如在完成一个习惯时，适当地给自己小奖励。 戒除一个坏习惯时，感到满足几乎不可能，因为你所做的只是在抗拒诱惑，并没有获得任何奖励和满足感。 解决方法是，让戒除习惯的奖励变得显而易见。 想要戒除乱花钱的习惯，每次放弃购买一件物品时，就把等额的数字存入另一个账户，而这个账户可以用来做任何你想做的事情，比如买新电脑，旅游…戒除坏习惯的感受就慢慢变得令人愉悦。 习惯追踪(Habit Tracker) # 习惯跟踪法：取得进步令人满意，借助视觉量度，清晰的看到自己的进步，更容易坚持下去。 习惯追踪的行为本身转化成了奖励的形式。从待办事项列表中划掉一个项目让人感觉心满意足。当感觉不错时，你更有可能坚持下去。习惯追踪让你更关注过程而不是结果。 习惯追踪提供了视觉证据，证明你在把自己塑造成为你特别想成为的那类人，这本身就是一种令人感觉愉快的即时、内在满足的形式。 习惯叠加与习惯追踪结合：在[当前习惯之后，我将[追踪我的习惯]。 习惯被打乱时，如何快速恢复 # 原则：绝不错过两次。 初犯不会毁了你。真正要命的是随之而来的不断重复的错误。错过一次是意外。错过两次是一种新习惯的开始。 书中提供的各种技巧和方法 # 阅读的过程中作者为培养好习惯提供了各种各样的方法，但是读完之后脑子里只有很模糊的印象，所以用表格总结了书中提到的方法和技巧，用 ⭐️ 标注出了我认为最喜欢的方法。\n方法 操作 原则 ⭐️ 忘记目标，专注体系 定下目标以后，制定能达到目标的计划和体系。接下来每天只落实计划，忘记要达成的是什么目标 让习惯坚持下去 习惯积分法 1)列出日常习惯；2)用“+”好标注好习惯，“-”号标注坏习惯，“=”号标注中性习惯 让它显而易见 指差确认 大声说出你想采取的行动和你预期的结果，让无意识习惯意识化 让它显而易见 执行意图 事先制定何时何行动的计划：我将在[时间]和[地点]做[事] 让它显而易见 习惯叠加 继[当前习惯]之后，我将[新习惯]。（让旧习惯成为触发新习惯的提示） 让它显而易见 ⭐️ 创建提示显而易见的环境 如果我们的环境充满触发习惯的显眼提示，我们更有可能去执行 让它显而易见 绑定喜好 把你需要做和愿意做的事绑定，继[我需要的习惯]之后，我将[我想要的习惯] 让它有吸引力 加入群体 当你处在某一群体中，你偏爱的行为被认定为是正常行为。当你看到别人每天都这样做时，会觉得培养新习惯似乎并不难。 让它有吸引力 ⭐️ 转变心态 改变看待事情的方式，将负担视为机遇：你不是“得”而是“想”做那些事。 让它有吸引力 激励仪式 将一个例行模式与心情愉悦的感受联系起来，比如深呼吸+微笑。 让它有吸引力 ⭐️ 2分钟法则 当你开始培养一个新习惯时，它所用时间不应超过2分钟。 让它简单易行 增强法 利用及时奖励来提高行为频度 让它令人愉悦 ⭐️ 习惯跟踪法 从待办事项列表中划掉一个项目让人感觉心满意足。当感觉不错时，你更有可能坚持下去。习惯追踪让你更关注过程而不是结果。 让它令人愉悦 ⭐️ 绝不错过两次 错过一次是意外，错过两次是一种新习惯的开始 让它令人愉悦 Highlights # 身份（identity）这个词最初来源于拉丁语单词essentitas，意思是存在，以及identidem，意思是反复。你的身份实际上就是你的“反复存在”。\n养成习惯的过程实际上就是成为你自己的过程。\n只有让生活的基本要素变得更容易，你才能创造自由思考和创造力所需的精神空间。\n支配我们行为的不是我们的环境中的各类物品，而是我们与它们之间的关系。事实上，这种思路有助于我们思考环境是怎样影响我们的行为的。不要把你的环境想象成充斥着各种物品，要把它想象成各种关系的综合体。\n尽可能避免将一种习惯的情境与另一种习惯的混在一起。一旦你开始混合不同的情境，你就会把各种习惯混为一谈——那些比较容易实行的习惯通常会占上风。\n从短期来看，你可以选择战胜诱惑。从长远来看，我们将成为我们生活环境的产物。\n我们一直想知道“别人会怎么看我”并根据答案相应地改变我们的行为。\n有许多不同的方法来满足相同的潜在动机。一个人可能会通过吸烟缓解情绪。另一个人通过跑步减轻焦虑。你目前的习惯不一定是解决你面临的问题的最佳方式；它们只是你掌握的方法。一旦你把一个解决方案和你需要解决的问题联系起来，你就会不断地反复加以应用。\n我们的行为在很大程度上取决于我们如何解释与我们相关的事件，而未必是事件本身的客观现实。\n实际上习惯本身并不是你想要的。你真正想要的是习惯带来的结果。\n重新设计你的生活，让对你来说最重要的事成为最容易做的事。\n做得比你希望的少总是好过什么都不做。\n不管你如何衡量你的进步，习惯追踪提供了一个简单的方法来让你的习惯更令人满意。每一次测量都给你提供了一点证据，证明你前进的大方向是正确的，并以自己出色的表现为傲，享受到略嫌短暂的即时快乐。\n很多时候，我们在培养习惯时会陷入全有全无的怪圈中。问题不在于出差错，而是如果不能做完美，就干脆不做的错误想法。\nNotes # 忘记目标，专注于每天做的小习惯，比如我要成为一个健康的人，那我就忘记这个目标而是专注于着每天的运动计划，水分的摄入以及油脂和糖分的减少摄入。\n在平时养成一个习惯却迟迟看不到结果的时候提醒自己不要焦虑，我只是在成为我想成为的人，这个目标和身份已经通过每天的行动和投票不断地强化了，从某种意义上来说，我的目标每天都在完成。\n当我要阅读时，不是在一天中心血来潮时读2页，而是把阅读这件事放进日历里，比如9点-9点半阅读30分钟。除了安排具体时间，也可以把读书这件事安排在我已有习惯之后：比如晚上吃完饭后阅读30分钟。\n习惯叠加的其他应用：洗完澡之后涂身体乳，早上刷完牙之后背单词…\n建立阅读的习惯：在手机屏幕的第一页放所有有关阅读的App，创建阅读的提示显而易见的环境。\n不同的环境和不同的行为要有明确的分界线。只在自习室学习，不要在床上学习，因为和床上的提示通常是与睡眠，放松，休息有关的，而学习是一个需要集中注意的专注活动，旧习惯的提示会干扰新习惯形成。\n培养护肤习惯的喜好绑定应用：晚上洗完澡以后，擦身体乳，擦完身体乳后可以看一集喜欢的情景喜剧。\n我想培养写Blog的习惯，那就多交一些同样在写Blog的朋友，加入写Blog的社区，与周围有同样习惯的人建立关联。\n当我某一天不想写Blog，转变看待这件事的心态，不要把写Blog视作负担，而是机遇，不是我必须要写Blog，而是我有机会展示我的成果，分享我的观点，I got to do this.\n我想培养写Blog的习惯，重要的不是每一篇都写得很完美，我只需要坚持写，不停地联系，让写点什么成为习惯，变得自动化，也许开始会写得很简单，没有人愿意看，这都没关系，重要的是我在不断练习的过程中会做得越来越好。\n很早以前在其他地方看过的“2分钟法则”版本是：当一件事情不超过2分钟就能做完，那就立刻去做。”\n当我发布一篇Blog后，在日历上划线，用习惯追踪让自己对这一行为产生满足感。\n如果在预定的时间没有发Blog，那么立刻在第二天补上，不能拖延2天以上。\n","date":"2022-08-06","permalink":"/booknote/atomic-habits/","section":"Book Note","summary":"如何设计生活，让好习惯更容易养成？","title":"《掌控习惯》"},{"content":" ","date":"2022-08-06","permalink":"/booknote/","section":"Book Note","summary":" ","title":"Book Note"},{"content":"","date":"2022-08-06","permalink":"/tags/habits/","section":"Tags","summary":"","title":"habits"},{"content":"","date":"2022-08-06","permalink":"/tags/productivity/","section":"Tags","summary":"","title":"productivity"},{"content":"独立博客现在(2022)听来像是很古早的产物。独立域名、服务器空间和原创内容组成了独立博客，听起来是很Geek的事。独立博客设置了一道技术门栏，进门以后的人都去做技术博客了（误）。\n想写一个博客是近一两年才有的想法，有了想法之后就有了疑惑：\n写博客应该写什么？ 我的文笔不好，写了没人看怎么办？ 如果我想写的东西别人已经写过了，我还有必要写吗？ \u0026hellip; 抱着这样的疑惑和犹豫迟迟没有开始，直到最近读到Alexey Guzey的 Why you should start a Blog Right Now 才恍然大悟，鼓励了我把想法付诸实践。\n为什么要写博客？ # 以输入来判断一个人是尤为无聊的 # 上半年在网上看到一段话：\n成就更关乎你输出的影响所带来的真正价值。你可以买全所有的奢侈品，你也可以看完所有的好电影，但这是世界对你的输入。以输入来判断一个人是尤为无聊的。\n这段话当头一棒把我敲醒，惊觉原来自己一直在接受被动输入。那些制定的读书计划，观影列表，储存的稍后读文章，都是计划着怎么向自己的大脑输入别人的想法。\n突然明白一个个体即使标记自己看了1000本书，1000部电影，他也不过是一个接受了世界很多输入的无聊的人。\n“我也要向世界输出一些东西。”\n于是有了这样的想法。\n好的思考方式不会通过阅读被动获得 # Alexey Guzey 在 Why You Should start a Blog Right Now 中写到：\nYou can read all the self-help books in the world. You can read all the blog posts in the world. It’s not enough. Good thinking doesn’t happen by passive osmosis of other people’s good thinking. You have to actually write essays and journals to debug yourself and your ideas.\n你可以读完世界上所有关于自救的书，读完所有的博客，但这远远不够，好的思考方式不会通过别人好的思考方式被动地渗透给你。你需要真正动笔写博客和日记来为自己和你的想法排错。\n我囤积了几十本待看的书，几十篇稍后读文章，这句话让我明白就算我把这些书和文章一字不落地看完了，我也并不会因此变得更聪明，阅读作者的好想法并不会获得作者写下好想法时的思考方式，写一点什么比看很多更重要。\n你只知道那些你创造的 # Ali Abdaal在 一期如何建立Second Brain的视频中提到 “You Only Know What You Make”。\n我们可以读想读的书，看想看的视频，听想听的播客，但你真正知道的，能真正影响你的生活的，能在你的未來項目中用到的，只有那些你创造的。比如读完书后做的读书总结，听完播客后自己写的见解，甚至是平时生活中产生的一个想法\u0026hellip;当我们和自己创造的内容交互，而不是依赖于已经存在的那些别人的材料，我们会对这个内容更熟悉，也可以通过自己的东西做出更有趣的内容来。\n我发现“你只知道那些你创造的东西”这个概念，和费曼学习法类似。费曼学习法认为：\nIf you can’t explain something in simple terms, you don’t understand it.\n如果你不能向其他人简单地解释一件事，那么你就是还没有真正弄懂它。\n向其他人简单地解释一件事，前置条件是“简单的解释”，所以你不能只是简单通过重复念别人的材料来解释，而是要根据别人的材料作自己的理解，再把自己的理解用简单的语句输出，这个输出，这个“简单的理解”，是你“创造”的东西。\n所以我决定，每读过一本书，看完一篇有价值的文章，不要在“看完”这个动作止步和自喜，而是要进一步根据看过的内容去创造，去检验自己是否有真的掌握那些重要的概念。\n写博客的好处 # 学得更快更好 # David Perell说：\nThe best way to learn faster is to have a stake in the outcome. 学得更快的最好方式是与结果的利害相关。\n当你意识到别人可能在看自己，你会想要做得更好，让自己看起来体面得当，担心自己可能会「不够体面」的潜在风险会让你的大脑像即将面对一盆浇过来的凉水一样警惕清醒。\nDavid Perell 认为公开写作就像邀请别人到家里做客，你会打扫房间，因为希望别人看到自己的家是干净的；会多次检查做饭的食材是否齐全，希望别人吃到的是你的好手艺。\n写博客时为了输出整洁又有清晰的内容，你会在思考，整理知识，用自己的逻辑和语言尽可能讲清楚一件事，而在这个过程中，你会不断地与知识材料交互，从而产生更深的理解。\n这一点与私有笔记不一样，因为私有笔记不管写成什么样也只有自己会看，没有社交压力，不可避免地可以偷懒。但公开写博客，你输出的内容影响着别人会怎么看你，即使想偷懒也会逼自己把不懂的地方搞清楚。\n《Atomic Habits》的作者James Clear也说过：\nIf you wish you would take something more seriously, do it publicly… Social pressure forces you to up your game. 如果你希望自己能更认真地对待某件事情，那就公开地去做\u0026hellip;\u0026hellip;社会压力逼你尽量提高你的水平。\n写作是最好的社交 # 如果你有同感，成人之后的交友变得很困难。我的原因大概是：\n缺少交友途径 盲目地去交友需要花时间去确定三观是否合得来，消耗心力 因为社恐，不希望线下社交 而写作是最好的社交方式，因为写作是一种反向的筛选，阅读过你的文章后，对你产生交流兴趣的人已经经过了一层筛选，对方很可能认同你的观点，对某件事有着相同的看法，你们有着一样的兴趣爱好，写作让你更有机率认识到你希望认识的朋友。\n写博客到底要写什么？ # 我在写什么这个问题上纠结了很久，也是我即使知道写博客有好处但是迟迟没能开始的原因。Alexey和Ali启发和指引了我。\nAlexey推荐写：\n分享个人经验，也许其他人会从中受益 写阅读别人的文章时，自己产生的不同意的观点 写和朋友交流时产生的、别人可能也会感兴趣的想法 收集自己认为很有趣，也许别人也会觉得有趣的东西 Ali推荐写：\n写至少对世界上一个人有帮助的内容（比如记录组装一台电脑的过程，学习语言时产生的学习心得… 写一本书的总结，从一本书中学到的观点，技巧，见解等 写听完一个播客后一直在脑子里忘不掉的那个观点 探索自己感兴趣的话题中的内容 记录你学到的东西 他们给的建议都是简单可行的，这些建议并不要求你去创造什么有很大价值的东西，只是记录，记录你的想法，记录你的过程，记录你的探索。\nAli解释他很喜欢的一句话 “Document, don’t create.”：\nCreating content and the concept of that is actually really hard. It feels like a big deal. But if you just think about documenting the stuff that you’re doing anyway. It becomes very easy to find ideas of things to write about.\n创造内容和创建概念实际上非常困难，让人感觉这是件大事。但是，如果只是考虑记录你正在做的事情，很容易就能找到要写的想法。\n为什么写非原创的东西有用？ # 这是 Alexey 在 Why you should start a Blog Right Now 中谈到的我最喜欢的内容。为什么写非原创的东西是有用的？你要写的读书笔记别人可能早就写过了，你记录的学到的东西也是可能别人已经分享过的…\nAlexey 认为：\n这有助于发现和支持那些不被重视的观点 你写的关于这个观点的文章，可能是说服读者去尝试这个观点的最后一遍 我认为第2点很重要，我反思自己作为读者的过程中，确实不太会在第一次看到一个观点时就去做点什么，而是经过一段时间的阅读后，再次遇到相似的观点一次两次，慢慢被说服，逐渐去接受。\n创作歌手Tessa Violet在 一期关于创造力的视频中回答评论 “我要怎么才能让我的歌曲听起来是原创的” 时讲这样说：\n如果一直担心自己一定要写出原创的东西，最后可能什么都写不出来。不要给自己压力，不用逼自己一定要原创，一定要写足够好的东西，这可以只是一件你在做的事，请允许你给你的创造力一次机会。\n结语 # 最后回答标题「独立博客过时以后，为什么开始写博客了？」，虽然独立博客是互联网早期的产物，但是它的意义从来没有过时过。自我成长和探索，是贯穿一生的事情。而在这个过程中，记录显得尤为重要，因为没有记录就没有发生，没有记录就会被遗忘。整理自己学到的，记录自己有共鸣的，对世界输出一些什么，通过创造来学习更多，这就是我开始写博客的原因。\n","date":"2022-07-29","permalink":"/blog/why-blog/","section":"Blog","summary":"写作即思考，不是我有什么话要说，是为了弄清楚我到底想说什么。","title":"独立博客过时以后，为什么开始写博客了？"},{"content":" About Me # 小綿尾巴是网名，你也可以叫我Mia。 我从 2022-07 开始写博客： 独立博客过时以后，为什么开始写博客了？ 学习日语中，日本語初心者，正在为了成为在日程序员而努力。 我关心技术、设计、工具、书籍、生产力、女性主义、个人成长、数字生活和一切让人觉得美好的事物。 About Site # 博客生日：2022-08-30 使用Hugo搭建，部署在GitHub Pages上： 如何用 GitHub Pages + Hugo 搭建个人博客 Now页面的灵感来源于 Derek Sivers Don\u0026rsquo;t be shy, let\u0026rsquo;s connect! # Twitter Telegram Channel - 在这里记录 Today I Learned，随手保存有共鸣的想法。 如果有任何问题，或者其他想要交流的信息，非常欢迎给我发邮件： cuttontail@gmail.com ","date":"0001-01-01","permalink":"/about/","section":"小綿尾巴","summary":"About Me # 小綿尾巴是网名，你也可以叫我Mia。 我从 2022-07 开始写博客： 独立博客过时以后，为什么开始写博客了？ 学习日语中，日本語初心者，正在为了成为在日程序员而努力。 我关心技术、设计、工具、书籍、生产力、女性主义、个人成长、数字生活和一切让人觉得美好的事物。 About Site # 博客生日：2022-08-30 使用Hugo搭建，部署在GitHub Pages上： 如何用 GitHub Pages + Hugo 搭建个人博客 Now页面的灵感来源于 Derek Sivers Don\u0026rsquo;t be shy, let\u0026rsquo;s connect!","title":"About"},{"content":"","date":"0001-01-01","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001-01-01","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"0001-01-01","permalink":"/series/","section":"Series","summary":"","title":"Series"}]